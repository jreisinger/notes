<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
  <title>Introduction to Go - Notes</title>
  <meta property="og:title" content="Introduction to Go - Notes" />
  <meta name="twitter:title" content="Introduction to Go - Notes" />
  <meta name="description" content="Types Go is statically typed - variables always have specific type and type cannot change during the program run time.
Types help us reason about what our program is doing and help us catch many errors.
Types are similar to sets in mathematics. They classify data into groups and determine:
 characteristics of data (e.g. all strings have length) operations that can be performed on data (e.g. len(&quot;a string&quot;)) data size (e.">
  <meta property="og:description" content="Types Go is statically typed - variables always have specific type and type cannot change during the program run time.
Types help us reason about what our program is doing and help us catch many errors.
Types are similar to sets in mathematics. They classify data into groups and determine:
 characteristics of data (e.g. all strings have length) operations that can be performed on data (e.g. len(&quot;a string&quot;)) data size (e.">
  <meta name="twitter:description" content="Types Go is statically typed - variables always have specific type and type cannot change during the program run time.
Types help us reason about what our program is doing and help us catch many …">
  <meta name="author" content="Jozef Reisinger"/>
  <meta property="og:site_name" content="Notes" />
  <meta property="og:url" content="https://jreisinger.github.io/posts/go-intro/" />
  <meta property="og:type" content="article" />
  <meta name="twitter:card" content="summary" />
  <meta name="generator" content="Hugo 0.49.2" />
  <link rel="stylesheet" href="https://jreisinger.github.io/notes/css/style.css" media="all" />
  <link rel="stylesheet" href="https://jreisinger.github.io/notes/css/syntax.css" media="all" />
  <link rel="stylesheet" href="https://jreisinger.github.io/notes/css/custom.css" media="all" />
  <script src="https://code.jquery.com/jquery-3.2.1.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script defer src="https://use.fontawesome.com/releases/v5.0.10/js/all.js" integrity="sha384-slN8GvtUJGnv6ca26v8EzVaR9DC58QEwsIk9q1QXdCU8Yu8ck/tL/5szYlBbqmS+" crossorigin="anonymous"></script>
</head>

<body>
<header class="site-header">
  <nav class="site-navi">
    <h1 class="site-title"><a href="https://jreisinger.github.io/notes/">Notes</a></h1>
    <iframe src="https://duckduckgo.com/search.html?site=jreisinger.github.io/notes,github.com/jreisinger/blog&prefill=Search Notes via DDG" style="overflow:hidden;margin:0;padding:0;width:408px;height:40px;" frameborder="0"></iframe>
    <ul class="site-navi-items">
      <li class="site-navi-item-categories"><a href="https://jreisinger.github.io/notes/categories/" title="Categories">Categories</a></li>
      <li class="site-navi-item-tags"><a href="https://jreisinger.github.io/notes/tags/" title="Tags">Tags</a></li>
    </ul>

    
    <ul>
      
        
        
        
        <a href="https://github.com/jreisinger/notes/tree/master/content/posts/go-intro.md">See on GitHub</a>
        
      
    </ul>

  </nav>
</header>
<hr class="site-header-bottom">


  <div class="main" role="main">
    <article class="article">
      
      
      <h1 class="article-title">Introduction to Go</h1>
      
      <hr class="article-title-bottom">
      <ul class="article-meta">
        <li class="article-meta-date"><time>July 22, 2019</time></li>
        <li class="article-meta-categories">
          <a href="https://jreisinger.github.io/notes/categories/prog/">
            <i class="fas fa-folder"></i>
            prog
          </a>&nbsp;
        </li>
        <li class="article-meta-tags">
          <a href="https://jreisinger.github.io/notes/tags/go/">
            <i class="fas fa-tag"></i>
            go
          </a>&nbsp;
        </li>
      </ul>
      
<aside class="toc">
  <nav id="TableOfContents">
<ul>
<li><a href="#types">Types</a>
<ul>
<li><a href="#numbers">Numbers</a></li>
<li><a href="#strings">Strings</a></li>
<li><a href="#booleans">Booleans</a></li>
</ul></li>
<li><a href="#variables">Variables</a></li>
<li><a href="#control-structures">Control Structures</a>
<ul>
<li><a href="#the-for-statement">The for Statement</a></li>
<li><a href="#the-if-and-switch-statements">The if and switch Statements</a></li>
</ul></li>
<li><a href="#more-built-in-types">More built-in types</a>
<ul>
<li><a href="#arrays">Arrays</a></li>
<li><a href="#slices">Slices</a>
<ul>
<li><a href="#append-operator"><code>append</code> operator</a></li>
<li><a href="#copy-operator"><code>copy</code> operator</a></li>
</ul></li>
<li><a href="#maps">Maps</a></li>
</ul></li>
<li><a href="#functions">Functions</a>
<ul>
<li><a href="#variadic-functions">Variadic functions</a></li>
<li><a href="#closures">Closures</a></li>
<li><a href="#recursion">Recursion</a></li>
<li><a href="#defer">defer</a></li>
<li><a href="#panic-and-recover">panic and recover</a></li>
<li><a href="#pointers">Pointers</a></li>
</ul></li>
<li><a href="#structs-and-interfaces">Structs and interfaces</a>
<ul>
<li><a href="#structs">Structs</a></li>
<li><a href="#methods">Methods</a></li>
<li><a href="#embedded-types">Embedded types</a></li>
<li><a href="#interfaces">Interfaces</a></li>
</ul></li>
<li><a href="#packages">Packages</a>
<ul>
<li><a href="#the-core-packages">The Core Packages</a>
<ul>
<li><a href="#input-output">Input/Output</a></li>
<li><a href="#files-and-folders">Files and Folders</a></li>
<li><a href="#errors">Errors</a></li>
</ul></li>
</ul></li>
<li><a href="#sources">Sources</a></li>
</ul>
</nav>
</aside>
      

<h1 id="types">Types</h1>

<p>Go is statically typed - variables always have specific type and type cannot
change during the program run time.</p>

<p>Types help us reason about what our program is doing and help us catch many
errors.</p>

<p>Types are similar to sets in mathematics. They classify data into groups and
determine:</p>

<ul>
<li>characteristics of data (e.g. all strings have length)</li>
<li>operations that can be performed on data (e.g. <code>len(&quot;a string&quot;)</code>)</li>
<li>data size (e.g. <code>int8</code>)</li>
<li>how data is stored in memory</li>
</ul>

<p>See also <a href="https://tour.golang.org/basics/11">Basic types</a>, <a href="https://tour.golang.org/basics/12">Zero values</a> and <a href="https://tour.golang.org/basics/13">Type conversions</a>.</p>

<h2 id="numbers">Numbers</h2>

<p>Computers use base-2 binary system to store and work with the numbers. So
computers count like this: 0, 1, 10, 11, 100, 110, 111, &hellip;</p>

<p>Integer types</p>

<ul>
<li>[u]int{8, 16, 32, 64}</li>
<li>machine dependent: uint, <strong>int</strong>, uintptr</li>
<li>byte - alias for uint8</li>
<li>rune - alias for int32 (represents a Unicode code point)</li>
</ul>

<p>Floating-point types</p>

<ul>
<li>float32 (single precision), <strong>float64</strong> (double precision)</li>
<li>complex64, complex128</li>
<li>contain decimal component (i.e. real numbers)</li>
<li>their actual representation on computer is quite complicated but not needed to
know to use them</li>
<li>inexact (1.01 – 0.99 using floating-point arithmetic results in
0.020000000000000018)</li>
<li>have certain size (32 or 64 bit)</li>
<li>NaN - not a number (for things like 0/0), +∞, -∞</li>
</ul>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="font-style:italic">// we use .0 to tell Go it&#39;s a floating-point number
</span><span style="font-style:italic"></span>fmt.Prinln(<span style="font-style:italic">&#34;1 + 1 =&#34;</span>, 1.0 + 1.0)</code></pre></div>
<h2 id="strings">Strings</h2>

<ul>
<li>sequences of characters used to represent text</li>
<li>made up of individual bytes, usually (but not always) one for each character</li>
</ul>

<p>String literals are created with:</p>

<ul>
<li>double quotes (<code>&quot;Hello world&quot;</code>) - cannot contain newlines and allow escape
sequeences (e.g. <code>\t</code>, <code>\n</code>)</li>
<li>backticks (<code>`Hello world`</code>)</li>
</ul>

<p>Common operations on strings:</p>

<ul>
<li>find length: <code>len(&quot;Hello world&quot;)</code></li>
<li>access a character: <code>&quot;Hello world[1]</code> -&gt; 101 instead of e because the
character is represented by a byte (i.e. and integer)</li>
<li>concatenate strings: <code>&quot;Hello &quot; + &quot;world&quot;</code> -&gt; Go figures out what to do based
on the type of the arguments</li>
</ul>

<h2 id="booleans">Booleans</h2>

<ul>
<li>special 1-bit integer type used to represent true and false (or on and off)</li>
<li>logical operators: <code>&amp;&amp;</code>, <code>||</code>, <code>!</code></li>
<li>truth tables define how these operators work</li>
</ul>

<h1 id="variables">Variables</h1>

<ul>
<li>variable - storage location, with a specific type and an associated name</li>
<li><a href="https://golang.org/ref/spec#Declarations_and_scope">scope</a> - the range of places where you are allowed to use a variable (&ldquo;Go is lexically scoped using block.&rdquo;)</li>
<li>constants - variables whose values cannot be changed during program run time</li>
</ul>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="font-weight:bold">package</span> main

<span style="font-weight:bold">import</span> (
    <span style="font-style:italic">&#34;fmt&#34;</span>
)

<span style="font-weight:bold">func</span> main() {
    fmt.Print(<span style="font-style:italic">&#34;Enter distance in feet: &#34;</span>)
    <span style="font-weight:bold">var</span> feet <span style="">float64</span> <span style="font-style:italic">// one way to define var
</span><span style="font-style:italic"></span>    fmt.Scanf(<span style="font-style:italic">&#34;%f&#34;</span>, &amp;feet)
    meters := feet * 0.3048 <span style="font-style:italic">// another way to define var
</span><span style="font-style:italic"></span>    fmt.Printf(<span style="font-style:italic">&#34;%.2f ft = %.2f m\n&#34;</span>, feet, meters)
}</code></pre></div>
<p>See also <a href="https://tour.golang.org/basics/14">Type inference</a>.</p>

<h1 id="control-structures">Control Structures</h1>

<h2 id="the-for-statement">The for Statement</h2>

<p>Other programming languages have various types of loops (while, until, foreach,
&hellip;). Go only has for loop that can be used in various ways, e.g.:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="font-style:italic">// traditional c-style
</span><span style="font-style:italic"></span><span style="font-weight:bold">for</span> i := 1; i &lt;= 10; i++ {
    fmt.Println(i)
}

i := 1              <span style="font-style:italic">// declaration + initialization
</span><span style="font-style:italic"></span><span style="font-weight:bold">for</span> i &lt;= 10 {       <span style="font-style:italic">// condition
</span><span style="font-style:italic"></span>    fmt.Println(i)
    i++             <span style="font-style:italic">// increment
</span><span style="font-style:italic"></span>}

<span style="font-style:italic">// loop over array/slice
</span><span style="font-style:italic"></span><span style="font-weight:bold">for</span> i, value := <span style="font-weight:bold">range</span> x {
    ...
}</code></pre></div>
<h2 id="the-if-and-switch-statements">The if and switch Statements</h2>

<p>If the if statement becomes too verbose use the switch statement.</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="font-weight:bold">for</span> i := 1; i &lt;= 10; i++ {
    <span style="font-weight:bold">switch</span> i { <span style="font-style:italic">// expression after switch can be omitted
</span><span style="font-style:italic"></span>    <span style="font-weight:bold">case</span> 1: fmt.Println(<span style="font-style:italic">&#34;one&#34;</span>)
    <span style="font-weight:bold">case</span> 5: fmt.Println(<span style="font-style:italic">&#34;five&#34;</span>)
    <span style="font-weight:bold">case</span> 6: fmt.Println(<span style="font-style:italic">&#34;six&#34;</span>)
    <span style="font-weight:bold">case</span> 10: fmt.Println(<span style="font-style:italic">&#34;ten&#34;</span>)
    <span style="font-weight:bold">default</span>: fmt.Println(i) <span style="font-style:italic">// similar to else
</span><span style="font-style:italic"></span>    }
}</code></pre></div>
<p>The value of the expressions (in this example <code>i</code>) is compared to the
expression following each <code>case</code> keyword. If they are equivalent the statements
following <code>:</code> are executed. The first one to succeed is chosen.</p>

<h1 id="more-built-in-types">More built-in types</h1>

<h2 id="arrays">Arrays</h2>

<p>Array is a numbered sequence of elements of a single type with a <em>fixed length</em>.</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="font-weight:bold">var</span> a1 [3]<span style="">int</span> <span style="font-style:italic">// array of three integers
</span><span style="font-style:italic"></span>a1[0] = 10
a1[1] = 20
a1[3] = 30

<span style="font-style:italic">// shorter syntax for creating arrays
</span><span style="font-style:italic"></span>a2 := [3]<span style="">int</span>{ 10, 20, 30, }</code></pre></div>
<p>Now, you rarely see arrays used directly in Go code :-).</p>

<h2 id="slices">Slices</h2>

<p>Slice is a segment of an array. Like arrays, they are indexable and have a length. Unlike arrays, the <em>length is allowed to change</em>.</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go">    <span style="font-weight:bold">var</span> s1 []<span style="">float64</span>            <span style="font-style:italic">// []
</span><span style="font-style:italic"></span>    s2 := make([]<span style="">float64</span>, 3)    <span style="font-style:italic">// [0 0 0]
</span><span style="font-style:italic"></span>
    <span style="font-style:italic">// define length (3) and capacity (5)
</span><span style="font-style:italic"></span>    s3 := make([]<span style="">float64</span>, 3, 5) <span style="font-style:italic">// [0 0 0]
</span><span style="font-style:italic"></span>
    <span style="font-style:italic">// create slice from array
</span><span style="font-style:italic"></span>    a := [5]<span style="">float64</span>{1,2,3,4,5}
    s4 := a[1:3]                <span style="font-style:italic">// [2 3]
</span><span style="font-style:italic"></span>    s5 := a[:]                  // [1 2 3 4 5]</code></pre></div>
<p>Slices are always associated with some array. The are like
<a href="https://tour.golang.org/moretypes/8">references</a> to arrays.</p>

<p>See also <a href="https://tour.golang.org/moretypes/9">Slice literals</a>.</p>

<h3 id="append-operator"><code>append</code> operator</h3>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go">s1 := []<span style="">int</span>{1,2,3}
s2 := append(s1, 4, 5)</code></pre></div>
<ul>
<li>adds elements onto the end of a slice and creates a <em>new slice</em></li>
<li>if there&rsquo;s sufficient capacity, the backing array&rsquo;s length is incremented</li>
<li>if not, a new backing array is created and all the existing elements are copied over</li>
</ul>

<p>See also <a href="https://tour.golang.org/moretypes/15">Appending to a slice</a>.</p>

<h3 id="copy-operator"><code>copy</code> operator</h3>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go">s1 := []<span style="">int</span>{1,2,3}
s2 := make([]<span style="">int</span>, 2)
<span style="font-style:italic">// func copy(dst, src []Type) int
</span><span style="font-style:italic"></span>copy(s2, s1)
// s1: [1,2,3], s2: [1,2]</code></pre></div>
<ul>
<li>all of the entries in <code>src</code> are copied into <code>dst</code> overwriting whatever is there</li>
<li>if lengths are not the same, the smaller of the two will be used</li>
</ul>

<p>See also <a href="https://golang.org/pkg/builtin/#copy">copy</a>.</p>

<h2 id="maps">Maps</h2>

<ul>
<li>unordered collection of key-value pairs (also called associative arrays, hash tables, or dictionaries)</li>
</ul>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="font-style:italic">// x is a map of strings into ints
</span><span style="font-style:italic"></span>
<span style="font-style:italic">// WRONG: this will yield a run time error
</span><span style="font-style:italic"></span><span style="font-weight:bold">var</span> x <span style="font-weight:bold">map</span>[<span style="">string</span>]<span style="">int</span>
x[<span style="font-style:italic">&#34;key&#34;</span>] = 10 <span style="font-style:italic">// panic: assignment to entry in nil map
</span><span style="font-style:italic"></span>
<span style="font-style:italic">// maps have to be initialized before they can be used
</span><span style="font-style:italic"></span><span style="font-weight:bold">var</span> x = make(<span style="font-weight:bold">map</span>[<span style="">string</span>]<span style="">int</span>)
x[<span style="font-style:italic">&#34;key&#34;</span>] = 10

<span style="font-style:italic">// delete an item from a map
</span><span style="font-style:italic"></span>delete(x, <span style="font-style:italic">&#34;key&#34;</span>)</code></pre></div>
<ul>
<li>maps are often used as lookup tables (dictionaries)</li>
</ul>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go">elements := <span style="font-weight:bold">map</span>[<span style="">string</span>]<span style="">string</span>{
    <span style="font-style:italic">&#34;H&#34;</span>:  <span style="font-style:italic">&#34;Hydrogen&#34;</span>,
    <span style="font-style:italic">&#34;He&#34;</span>: <span style="font-style:italic">&#34;Helium&#34;</span>,
    <span style="font-style:italic">&#34;Li&#34;</span>: <span style="font-style:italic">&#34;Lithium&#34;</span>,
}

<span style="font-weight:bold">if</span> name, ok := elements[<span style="font-style:italic">&#34;He&#34;</span>]; ok {
    fmt.Printf(<span style="font-style:italic">&#34;He is %s\n&#34;</span>, name)
}</code></pre></div>
<h1 id="functions">Functions</h1>

<p>A function (aka a procedure, or a subroutine) is an independent section of code that maps zero or more input parameters to zero or more output parameters:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">Inputs -&gt; [ func f(i, j int) int {} ] -&gt; Outputs</pre></div>
<ul>
<li>collectively, the parameters (i, j) and the return type (int) are called function&rsquo;s signature</li>
</ul>

<p>Functions form call stacks:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="font-weight:bold">func</span> main() {
    fmt.Println(f1())
}

<span style="font-weight:bold">func</span> f1() <span style="">int</span> {
    <span style="font-weight:bold">return</span> f2()
}

<span style="font-weight:bold">func</span> f2() <span style="">int</span> {
    <span style="font-weight:bold">return</span> 1
}</code></pre></div><div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4">                            +----+
                            | f2 | return
                            +----+
              +----+        +----+        +----+
              | f1 |   f2   | f1 |        | f1 | return
              +----+        +----+        +----+
+----+        +----+        +----+        +----+        +----+
|main|   f1   |main|        |main|        |main|        |main|
+----+        +----+        +----+        +----+        +----+</pre></div>
<ul>
<li>each time we call a function, we push it onto the call stack</li>
<li>each time we return from a function, we pop it off of the stack</li>
</ul>

<p>Return types can have names:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="font-weight:bold">func</span> f2() (r <span style="">int</span>) {
    r := 1
    <span style="font-weight:bold">return</span>
}</code></pre></div>
<p>Multiple values can be returned:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="font-weight:bold">func</span> f() (<span style="">int</span>, <span style="">int</span>) {
    <span style="font-weight:bold">return</span> 4, 2
}

<span style="font-weight:bold">func</span> main() {
    x, y := f()
}</code></pre></div>
<p>Multiple values are often used to return an error value along with the result (<code>x, err := f()</code>), or a boolean to indicate success (<code>x, ok := f()</code>).</p>

<h2 id="variadic-functions">Variadic functions</h2>

<p>There is a special form available for the last parameter:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="font-style:italic">// sump up zero or more integers
</span><span style="font-style:italic"></span><span style="font-weight:bold">func</span> sum(args ...<span style="">int</span>) <span style="">int</span> {     <span style="font-style:italic">// prefix ellipsis
</span><span style="font-style:italic"></span>    total := 0
    <span style="font-weight:bold">for</span> _, v := <span style="font-weight:bold">range</span> args {
        total += v
    }
    <span style="font-weight:bold">return</span> total
}

<span style="font-weight:bold">func</span> main() {
    fmt.Println(sum())
    fmt.Println(sum(1, 2))

    xs := []<span style="">int</span>{1,2,3}
    fmt.Println(sum(xs...))     <span style="font-style:italic">// suffix ellipsis
</span><span style="font-style:italic"></span>}</code></pre></div>
<p>fmt.Println can take any number of values (&hellip;) of any type (interface{}):</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="font-weight:bold">func</span> Println(a ...<span style="font-weight:bold">interface</span>{}) (n <span style="">int</span>, err <span style="">error</span>)</code></pre></div>
<h2 id="closures">Closures</h2>

<p>It&rsquo;s possible to create functions inside functions. These local functions have
access to other local variables:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="font-weight:bold">func</span> main() {
    <span style="font-style:italic">// local variable accessible by increment
</span><span style="font-style:italic"></span>    x := 0

    <span style="font-style:italic">// local variable of type func() int
</span><span style="font-style:italic"></span>    increment := <span style="font-weight:bold">func</span>() <span style="">int</span> {
        x++
        <span style="font-weight:bold">return</span> x
    }

    fmt.Println(increment()) <span style="font-style:italic">// 1
</span><span style="font-style:italic"></span>    fmt.Println(increment()) <span style="font-style:italic">// 2
</span><span style="font-style:italic"></span>}</code></pre></div>
<ul>
<li>a function like this together with nonlocal variables it references is know
as closure</li>
</ul>

<p>One way to use closure is to write a function that returns another function:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="font-weight:bold">func</span> makeEvenGenerator() <span style="font-weight:bold">func</span>() <span style="">uint</span> {
    i := uint(0) <span style="font-style:italic">// unlike normal local variable this one persists between calls
</span><span style="font-style:italic"></span>    <span style="font-weight:bold">return</span> <span style="font-weight:bold">func</span>() (ret <span style="">uint</span>) {
        ret = i
        i += 2
        <span style="font-weight:bold">return</span>
    }
}

<span style="font-weight:bold">func</span> main() {
    nextEven := makeEvenGenerator()
    fmt.Println(nextEven()) <span style="font-style:italic">// 0
</span><span style="font-style:italic"></span>    fmt.Println(nextEven()) <span style="font-style:italic">// 2
</span><span style="font-style:italic"></span>    fmt.Println(nextEven()) <span style="font-style:italic">// 4
</span><span style="font-style:italic"></span>}</code></pre></div>
<h2 id="recursion">Recursion</h2>

<p>A function is able to call itself:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="font-weight:bold">func</span> factorial(x <span style="">uint</span>) <span style="">uint</span> {
    <span style="font-weight:bold">if</span> x == 0 {
        <span style="font-weight:bold">return</span> 1
    }
    <span style="font-weight:bold">return</span> x * factorial(x-1)
}</code></pre></div>
<p>factorial(2):</p>

<ol>
<li>Is x == 0? No (x is 2).</li>
<li>Find the factorial of x - 1.

<ol>
<li>Is x == 0? No (x is 1).</li>
<li>Find the factorial of x - 1.

<ol>
<li>Is x == 0? Yes, return 1.</li>
</ol></li>
<li>Return 1 * 1.</li>
</ol></li>
<li>Return 2 * 1.</li>
</ol>

<h2 id="defer">defer</h2>

<p>defer schedules a function call to be run before a function returns. It&rsquo;s often used when resources need to be freed in some way, e.g.:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="font-weight:bold">func</span> main() {
    f, _ := os.Open(filename)
    <span style="font-weight:bold">defer</span> f.Close()
}</code></pre></div>
<p>This has three advantages:</p>

<ul>
<li>you keep the closing call close to the opening call</li>
<li>if a function had multiple return calls (like within an if statement) defer would call Close before any of them</li>
<li>deferred functions run even if a runtime panic occurs</li>
</ul>

<h2 id="panic-and-recover">panic and recover</h2>

<ul>
<li><code>panic</code> causes a runtime error immediately stopping the function&rsquo;s execution</li>
<li><code>recover</code> stops the panic and returns the value that was passed to <code>panic</code></li>
</ul>

<p>WRONG:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="font-weight:bold">func</span> main() {
    panic(<span style="font-style:italic">&#34;PANIC&#34;</span>)
    str := recover() <span style="font-style:italic">// this will never happen!
</span><span style="font-style:italic"></span>    fmt.Println(str)
}</code></pre></div>
<p>CORRECT:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="font-weight:bold">func</span> main() {
    <span style="font-weight:bold">defer</span> <span style="font-weight:bold">func</span>() {
        str := recover()
        fmt.Println(str)
    }()
    panic(<span style="font-style:italic">&#34;PANIC&#34;</span>)
}</code></pre></div>
<p>A panic generally indicates a programmer&rsquo;s error or an exceptional condition that&rsquo;s not easy to recover from.</p>

<p>See <a href="https://blog.golang.org/defer-panic-and-recover">https://blog.golang.org/defer-panic-and-recover</a> for more.</p>

<h2 id="pointers">Pointers</h2>

<p>Normally a function&rsquo;s argument is copied:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="font-weight:bold">func</span> zero(x <span style="">int</span>) {
    x = 0
}

<span style="font-weight:bold">func</span> main() {
    x := 1
    zero(x)
    <span style="font-style:italic">// x is still 1
</span><span style="font-style:italic"></span>}</code></pre></div>
<p>If we want to modify the original argument one way to do it is to use a special data type known as a pointer:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="font-weight:bold">func</span> zero(xPtr *<span style="">int</span>) {
    *xPtr = 0
}

<span style="font-weight:bold">func</span> main() {
    x := 1
    zero(&amp;x)
    <span style="font-style:italic">// x is 0
</span><span style="font-style:italic"></span>}</code></pre></div>
<p>Pointers reference a <em>location</em> in memory where a value is stored rather than the <em>value</em> itself.</p>

<ul>
<li><code>*</code> represents a pointer, e.g. <code>*int</code> means a pointer to an integer value</li>
<li><code>*</code> is also used to dereference a pointer variable (<code>*xPtr</code>), i.e. to get to the value a pointer points to</li>
<li><code>&amp;</code> operator finds the memory location (address) of a variable</li>
</ul>

<p>Another way to get a pointer is to use the <code>new</code> built-in function:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go">xPtr := new(<span style="">int</span>)</code></pre></div>
<ul>
<li><code>new</code> takes a type as an argument, allocates enough memory to fit a value of that type, and returns a pointer to it</li>
</ul>

<p>Go is a garbage-collected language. It means memory is cleaned up automatically when nothing refers to it anymore.</p>

<p>Pointers are rarely used with Go&rsquo;s built-in types but are extremely useful when paired with structs.</p>

<h1 id="structs-and-interfaces">Structs and interfaces</h1>

<p>At some point it would become tedious and error prone to write programs using only Go&rsquo;s built-in types.</p>

<h2 id="structs">Structs</h2>

<p>A struct is a type that contains named fields:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="font-style:italic">// Circle represents, well, a circle.
</span><span style="font-style:italic"></span><span style="font-weight:bold">type</span> Circle <span style="font-weight:bold">struct</span> {
    x, y, r <span style="">float64</span>
}

<span style="font-style:italic">// Several ways to do initialization.
</span><span style="font-style:italic"></span><span style="font-weight:bold">var</span> c Circle
c := new(Circle) <span style="font-style:italic">// returns pointer
</span><span style="font-style:italic"></span>c := Circle{x: 0, y: 0, r: 5}
c := Circle{0, 0, 5}
c := &amp;Circle{0, 0, 5} <span style="font-style:italic">// most typical
</span><span style="font-style:italic"></span>
<span style="font-style:italic">// Accessing fields.
</span><span style="font-style:italic"></span>fmt.Println(c.x)
c.r = 10</code></pre></div>
<h2 id="methods">Methods</h2>

<p>Using structs with functions:</p>

<p>A normal function:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="font-weight:bold">func</span> circleArea(c *Circle) <span style="">float64</span> {
    <span style="font-weight:bold">return</span> math.Pi * c.r*c.r <span style="font-style:italic">// no dereferencing needed... hm
</span><span style="font-style:italic"></span>}

c := Circle{0, 0, 5}
fmt.Println(circleArea(&amp;c))</code></pre></div>
<p>A special function - method:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="font-weight:bold">func</span> (c *Circle) area() <span style="">float64</span> { <span style="font-style:italic">// (c *Circle) is called a receiver
</span><span style="font-style:italic"></span>    <span style="font-weight:bold">return</span> math.Pi * c.r*c.r
}

c := Circle{0, 0, 5}
fmt.Println(c.area()) // Go automatically knows to pass a pointer to the circle</code></pre></div>
<h2 id="embedded-types">Embedded types</h2>

<p>A struct&rsquo;s fields usually represent the <em>has-a</em> relationship, e.g. <code>Person</code> has a name:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="font-weight:bold">type</span> Person <span style="font-weight:bold">struct</span> {
    Name <span style="">string</span>
}

<span style="font-weight:bold">func</span> (p *Person) Talk() {
    fmt.Println(<span style="font-style:italic">&#34;Hi, my name is&#34;</span>, p.Name)
}</code></pre></div>
<p>We use embedded types (anonymous fields) to represent the <em>is-a</em> relationship, e.g. <code>Android</code> is a person (so it can <code>Talk()</code>):</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="font-weight:bold">type</span> Android <span style="font-weight:bold">struct</span> {
    Person <span style="font-style:italic">// embedded type
</span><span style="font-style:italic"></span>    Model <span style="">string</span>
}

a := new(Android) <span style="font-style:italic">// you cannot do &amp;Android{Name: &#34;R2D2&#34;} here
</span><span style="font-style:italic"></span>a.Name = <span style="font-style:italic">&#34;R2D2&#34;</span>
a.Talk() // could be also: a.Person.Talk()</code></pre></div>
<h2 id="interfaces">Interfaces</h2>

<p>Interfaces are similar to structs but instead of fields they have a method set. A method set is a list of methods that a type must have in order to <em>implement</em> the interface. We can use interface types as arguments to functions.</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="font-weight:bold">package</span> main

<span style="font-weight:bold">import</span> (
    <span style="font-style:italic">&#34;fmt&#34;</span>
    <span style="font-style:italic">&#34;math&#34;</span>
)

<span style="font-weight:bold">type</span> Shape <span style="font-weight:bold">interface</span> {
    area() <span style="">float64</span> <span style="font-style:italic">// any type that has area method is a Shape
</span><span style="font-style:italic"></span>}
<span style="font-weight:bold">func</span> totalArea(shapes ...Shape) <span style="">float64</span> { <span style="font-style:italic">// interface (not a type) as argument
</span><span style="font-style:italic"></span>    <span style="font-weight:bold">var</span> area <span style="">float64</span>
    <span style="font-weight:bold">for</span> _, s := <span style="font-weight:bold">range</span> shapes {
        area += s.area()
    }
    <span style="font-weight:bold">return</span> area
}

<span style="font-style:italic">// Circle type with area method.
</span><span style="font-style:italic"></span><span style="font-weight:bold">type</span> Circle <span style="font-weight:bold">struct</span> {
    x, y, r <span style="">float64</span>
}
<span style="font-weight:bold">func</span> (c *Circle) area() <span style="">float64</span> {
    <span style="font-weight:bold">return</span> math.Pi * c.r * c.r
}

<span style="font-style:italic">// Rectangle type with area method.
</span><span style="font-style:italic"></span><span style="font-weight:bold">type</span> Rectangle <span style="font-weight:bold">struct</span> {
    x1, y1, x2, y2 <span style="">float64</span>
}
<span style="font-weight:bold">func</span> (r *Rectangle) area() <span style="">float64</span> {
    l := distance(r.x1, r.y1, r.x1, r.y2)
    w := distance(r.x1, r.y1, r.x2, r.y1)
    <span style="font-weight:bold">return</span> l * w
}

<span style="font-weight:bold">func</span> distance(x1, y1, x2, y2 <span style="">float64</span>) <span style="">float64</span> {
    a := x2 - x1
    b := y2 - y1
    <span style="font-weight:bold">return</span> math.Sqrt(a*a + b*b)
}

<span style="font-weight:bold">func</span> main() {
    c := &amp;Circle{0, 0, 5}
    r := &amp;Rectangle{0, 0, 10, 10}
    tot := totalArea(c, r)
    fmt.Println(tot)
}</code></pre></div>
<p>Interfaces can also be used as fields:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="font-weight:bold">type</span> MultiShape <span style="font-weight:bold">struct</span> {
    shapes []Shape
}

multiShape := MultiShape{
    shapes: []Shape{
        Circle{0, 0, 5},
        Rectangle{0, 0, 10, 10},
    },
}

<span style="font-style:italic">// Turn MultiShape into a Shape by giving it an area method.
</span><span style="font-style:italic"></span><span style="font-weight:bold">func</span> (m *MultiShape) area() <span style="">float64</span> {
    <span style="font-weight:bold">var</span> area <span style="">float64</span>
    <span style="font-weight:bold">for</span> _, s :+ <span style="font-weight:bold">range</span> m.shapes {
        area += s.area()
    }
    <span style="font-weight:bold">return</span> area
}</code></pre></div>
<p>Now a MultiShape can contain Circles, Rectangles, or even other MultiShapes.</p>

<p>See also John Graham-Cumming: <a href="https://learning.oreilly.com/learning-paths/learning-path-go/9781491990384/9781491913871-video191862">Interfaces</a>.</p>

<h1 id="packages">Packages</h1>

<ul>
<li>Go was designed to encourage good software engineering practices</li>
<li>one of them is code reuse (DRY - Don&rsquo;t Repeat Yourself): functions, packages</li>
</ul>

<h2 id="the-core-packages">The Core Packages</h2>

<h3 id="input-output">Input/Output</h3>

<p><a href="https://golang.org/pkg/io/">io</a> package consists of a few functions, but mostly interfaces used in other packages. The two main interfaces are <code>Reader</code> and <code>Writer</code>. <code>Reader</code>s support reading via the <code>Read</code> method. <code>Writer</code>s support writing via the <code>Write</code> method. Many functions in Go take Readers or Writers as arguments. E.g. the io.Copy function copies data from a Reader to a Writer:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="font-weight:bold">func</span> Copy(dst Writer, src Reader) (written <span style="">int64</span>, err <span style="">error</span>)</code></pre></div>
<p>To read/write to a <code>[]byte</code> or a <code>string</code>, you can use the <code>Buffer</code> type (struct) from <a href="https://golang.org/pkg/bytes">bytes</a> package:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="font-weight:bold">var</span> b bytes.Buffer
b.Write([]byte(<span style="font-style:italic">&#34;Hello &#34;</span>))
fmt.Fprintf(&amp;b, <span style="font-style:italic">&#34;world!&#34;</span>)
b.WriteTo(os.Stdout)</code></pre></div>
<ul>
<li>a <code>Buffer</code> doesn&rsquo;t have to be initialized</li>
<li>it supports both the <code>Reader</code> and <code>Writer</code> interfaces</li>
<li>you can convert it into a <code>[]byte</code> by calling <code>buf.Bytes()</code></li>
<li>if you only need to read from a string, you can use the more efficient <code>strings.NewReader</code> function</li>
</ul>

<p><code>bufio</code> package helps make input and output efficient and convenient. Its <code>Scanner</code> type reads input and breaks it into lines or words. <code>bufio</code> is good for &ldquo;streaming&rdquo; mode where input is read and broken into lines on the fly:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="font-style:italic">// Dup1 prints the text of each line that appears more than
</span><span style="font-style:italic">// once in the standard input, preceded by its count.
</span><span style="font-style:italic"></span><span style="font-weight:bold">package</span> main

<span style="font-weight:bold">import</span> (
    <span style="font-style:italic">&#34;bufio&#34;</span>
    <span style="font-style:italic">&#34;fmt&#34;</span>
    <span style="font-style:italic">&#34;os&#34;</span>
)

<span style="font-weight:bold">func</span> main() {
    counts := make(<span style="font-weight:bold">map</span>[<span style="">string</span>]<span style="">int</span>)
    input := bufio.NewScanner(os.Stdin) <span style="font-style:italic">// input is a ref to bufio.Scanner type
</span><span style="font-style:italic"></span>
    <span style="font-weight:bold">for</span> input.Scan() {          <span style="font-style:italic">// read the next line, remove newline and return true
</span><span style="font-style:italic"></span>        counts[input.Text()]++  <span style="font-style:italic">// input.Text() returns the line read
</span><span style="font-style:italic"></span>    }

    <span style="font-weight:bold">for</span> line, n := <span style="font-weight:bold">range</span> counts {
        <span style="font-weight:bold">if</span> n &gt; 1 {
            fmt.Printf(<span style="font-style:italic">&#34;%d\t%s\n&#34;</span>, n, line)
        }
    }
}</code></pre></div>
<h3 id="files-and-folders">Files and Folders</h3>

<p>The easiest way to open a file:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="font-weight:bold">package</span> main

<span style="font-weight:bold">import</span> (
    <span style="font-style:italic">&#34;fmt&#34;</span>
    <span style="font-style:italic">&#34;io/ioutil&#34;</span>
)

<span style="font-weight:bold">func</span> main() {
    bs, err := ioutil.ReadFile(<span style="font-style:italic">&#34;/etc/passwd&#34;</span>)
    <span style="font-weight:bold">if</span> err != <span style="font-weight:bold">nil</span> {
        <span style="font-style:italic">// handle error here
</span><span style="font-style:italic"></span>        <span style="font-weight:bold">return</span>
    }
    str := string(bs)
    fmt.Println(str)
}</code></pre></div>
<p>Create a file:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="font-weight:bold">package</span> main

<span style="font-weight:bold">import</span> (
    <span style="font-style:italic">&#34;os&#34;</span>
)

<span style="font-weight:bold">func</span> main() {
    file, err := os.Create(<span style="font-style:italic">&#34;test.txt&#34;</span>) <span style="font-style:italic">// file is os.File
</span><span style="font-style:italic"></span>    <span style="font-weight:bold">if</span> err != <span style="font-weight:bold">nil</span> {
        <span style="font-style:italic">// handler error here
</span><span style="font-style:italic"></span>        <span style="font-weight:bold">return</span>
    }
    <span style="font-weight:bold">defer</span> file.Close()
    file.WriteString(<span style="font-style:italic">&#34;test&#34;</span>)
}</code></pre></div>
<p>Get contents of a directory:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="font-weight:bold">package</span> main

<span style="font-weight:bold">import</span> (
    <span style="font-style:italic">&#34;fmt&#34;</span>
    <span style="font-style:italic">&#34;os&#34;</span>
)

<span style="font-weight:bold">func</span> main() {
    dir, err := os.Open(<span style="font-style:italic">&#34;.&#34;</span>)
    <span style="font-weight:bold">if</span> err != <span style="font-weight:bold">nil</span> {
        <span style="font-style:italic">// handle error here
</span><span style="font-style:italic"></span>        <span style="font-weight:bold">return</span>
    }
    <span style="font-weight:bold">defer</span> dir.Close()

    fileInfos, err := dir.Readdir(-1) <span style="font-style:italic">// -1 means return all entries
</span><span style="font-style:italic"></span>    <span style="font-weight:bold">if</span> err != <span style="font-weight:bold">nil</span> {
        <span style="font-weight:bold">return</span>
    }
    <span style="font-weight:bold">for</span> _, fi := <span style="font-weight:bold">range</span> fileInfos {
        fmt.Println(fi.Name())
    }
}</code></pre></div>
<p>Recursively walk a folder (read the folder’s contents, all the subfolders, all the sub-subfolders, etc.):</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="font-weight:bold">package</span> main

<span style="font-weight:bold">import</span> (
    <span style="font-style:italic">&#34;fmt&#34;</span>
    <span style="font-style:italic">&#34;os&#34;</span>
    <span style="font-style:italic">&#34;path/filepath&#34;</span>
)

<span style="font-weight:bold">func</span> main() {
    <span style="font-style:italic">// func() is called for every file and folder in &#34;.&#34;
</span><span style="font-style:italic"></span>    filepath.Walk(<span style="font-style:italic">&#34;.&#34;</span>, <span style="font-weight:bold">func</span>(path <span style="">string</span>, info os.FileInfo, err <span style="">error</span>) <span style="">error</span> {
        fmt.Println(path)
        <span style="font-weight:bold">return</span> <span style="font-weight:bold">nil</span>
    })
}</code></pre></div>
<h3 id="errors">Errors</h3>

<p>Go has a built-in type for errors (the <code>error</code> type). We can also create our own errors:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="font-weight:bold">package</span> main

<span style="font-weight:bold">import</span> <span style="font-style:italic">&#34;errors&#34;</span>

<span style="font-weight:bold">func</span> main() {
    err := errors.New(<span style="font-style:italic">&#34;error message&#34;</span>)
}</code></pre></div>
<h1 id="sources">Sources</h1>

<ul>
<li>Caleb Doxsey: Introducing Go (O&rsquo;Reilly, 2016)</li>
<li>Donovan, Kernighan: The Go Programming Language (Addison-Wesley, 2016)</li>
<li><a href="https://tour.golang.org">A Tour of Go</a></li>
</ul>

    </article>

    
    <div class="disqus-comments">
      <div id="disqus_thread"></div>
<script type="application/javascript">
    var disqus_config = function () {
    
    
    
    };
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
            return;
        }
        var d = document, s = d.createElement('script'); s.async = true;
        s.src = '//' + "notes-4" + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
    </div>

    <ul class="pager article-pager">
      <li class="pager-newer pager-noitem">&lt; Newer</li>
      <li class="pager-older">
        <a href="https://jreisinger.github.io/notes/posts/concurrency-and-channels/" data-toggle="tooltip" data-placement="top" title="Concurrency and Channels">Older &gt;</a>
      </li>
    </ul>
  </div>


<div class="site-footer">
  <div class="copyright"></div>
  <ul class="site-footer-items">
    <li class="site-footer-item-about"><a href="https://jreisinger.github.io/about" title="About">About</a></li>
  </ul>
  <div class="powerdby">
    Powered by <a href="https://gohugo.io/">Hugo</a> and <a href="https://github.com/taikii/whiteplain">Whiteplain</a>
  </div>
</div>
<script src="https://jreisinger.github.io/notes/js/script.js"></script>
<script src="https://jreisinger.github.io/notes/js/custom.js"></script>

<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
	ga('create', 'UA-124886160-1', 'auto');
	
	ga('send', 'pageview');
}
</script>


</body>
</html>
