<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>prog on Notes</title>
    <link>https://jreisinger.github.io/notes/categories/prog/</link>
    <description>Recent content in prog on Notes</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Mon, 22 Jul 2019 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://jreisinger.github.io/notes/categories/prog/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Introduction to Go</title>
      <link>https://jreisinger.github.io/notes/posts/go-intro/</link>
      <pubDate>Mon, 22 Jul 2019 00:00:00 +0000</pubDate>
      
      <guid>https://jreisinger.github.io/notes/posts/go-intro/</guid>
      <description>Types Go is statically typed - variables always have specific type and type cannot change during the program run time.
Types help us reason about what our program is doing and help us catch many errors.
Types are similar to sets in mathematics. They classify data into groups and determine:
 characteristics of data (e.g. all strings have length) operations that can be performed on data (e.g. len(&amp;quot;a string&amp;quot;)) data size (e.</description>
    </item>
    
    <item>
      <title>TCP sockets with Go</title>
      <link>https://jreisinger.github.io/notes/posts/go-tcp-sockets/</link>
      <pubDate>Fri, 25 Jan 2019 00:00:00 +0000</pubDate>
      
      <guid>https://jreisinger.github.io/notes/posts/go-tcp-sockets/</guid>
      <description>Client This is an HTTP client implemented using socket-level programming:
// Usage: go run telnet.go package main import ( &amp;#34;bufio&amp;#34; &amp;#34;fmt&amp;#34; &amp;#34;net&amp;#34; ) func main() { // NOTE: ignoring errors by storing them into _  conn, _ := net.Dial(&amp;#34;tcp&amp;#34;, &amp;#34;golang.org:80&amp;#34;) // Connect over TCP  fmt.Fprintf(conn, &amp;#34;GET / HTTP/1.0\r\n\r\n&amp;#34;) // Send string over the connection  status, _ := bufio.NewReader(conn).ReadString(&amp;#39;\n&amp;#39;) fmt.Print(status) // Print the first response line } To add a timeout you can use the Dialer structure (I&amp;rsquo;ve also added error checking + reading from command line arguments):</description>
    </item>
    
    <item>
      <title>Perl One Liners</title>
      <link>https://jreisinger.github.io/notes/posts/perl-one-liners/</link>
      <pubDate>Wed, 26 Sep 2018 00:00:00 +0000</pubDate>
      
      <guid>https://jreisinger.github.io/notes/posts/perl-one-liners/</guid>
      <description>I think Perl one liners are still super useful (even Kubernetes people like them to do their jobs :-). They are small Perl programs that are run directly from a command line (ex. on Unix/Linux, Cygwin). For a deeper dive see Famous Perl One-Liners Explained. If you want a book have a look at Minimal Perl for UNIX and Linux People.
perl command line switches  -e &#39;&amp;lt;code&amp;gt;&#39; (execute) &amp;ndash; execute &amp;lt;code&amp;gt; -E &#39;&amp;lt;code&amp;gt;&#39; (execute) &amp;ndash; execute &amp;lt;code&amp;gt; enabling feature bundle (like use 5.</description>
    </item>
    
  </channel>
</rss>