<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Go on Notes</title>
    <link>https://jreisinger.github.io/notes/tags/go/</link>
    <description>Recent content in Go on Notes</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Wed, 09 Oct 2019 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://jreisinger.github.io/notes/tags/go/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Go Strings</title>
      <link>https://jreisinger.github.io/notes/posts/go-strings/</link>
      <pubDate>Wed, 09 Oct 2019 00:00:00 +0000</pubDate>
      
      <guid>https://jreisinger.github.io/notes/posts/go-strings/</guid>
      <description>What is a string String is a read-only slice of bytes. A string can hold arbitrary bytes not just UTF-8 text or any other predefined format. Here is a string literal that uses the \xNN notation (hex values of a byte range from 00 to FF):
const sample = &amp;#34;\xbd\xb2\x3d\xbc\x20\xe2\x8c\x98&amp;#34; Printing strings // Print the string directly. fmt.Print(sample) // ��=� ⌘  // Get individual bytes by looping over the string.</description>
    </item>
    
    <item>
      <title>Introduction to Go</title>
      <link>https://jreisinger.github.io/notes/posts/go-intro/</link>
      <pubDate>Mon, 22 Jul 2019 00:00:00 +0000</pubDate>
      
      <guid>https://jreisinger.github.io/notes/posts/go-intro/</guid>
      <description>Types Go is statically typed - variables always have specific type and type cannot change during the program run time.
Types help us reason about what our program is doing and help us catch many errors.
Types are similar to sets in mathematics. They classify data into groups and determine:
 characteristics of data (e.g. all strings have length) operations that can be performed on data (e.g. len(&amp;quot;a string&amp;quot;)) data size (e.</description>
    </item>
    
    <item>
      <title>Concurrency and Channels</title>
      <link>https://jreisinger.github.io/notes/posts/concurrency-and-channels/</link>
      <pubDate>Mon, 06 May 2019 00:00:00 +0000</pubDate>
      
      <guid>https://jreisinger.github.io/notes/posts/concurrency-and-channels/</guid>
      <description>A goroutine is a function capable of running concurrently with other functions. Create a gouroutine with the go keyword.
A channel is a way for gouroutines to communicate with each other and synchronize their execution.
When pinger or ponger attempts to send a message on the channel, it will wait until printer is ready to receive the message (blocking):
package main import ( &amp;#34;fmt&amp;#34; &amp;#34;time&amp;#34; ) func main() { ch := make(chan string) go pinger(ch) go ponger(ch) go printer(ch) // Wait for Enter to exit.</description>
    </item>
    
    <item>
      <title>JSON Serialization with Go</title>
      <link>https://jreisinger.github.io/notes/posts/go-json/</link>
      <pubDate>Tue, 29 Jan 2019 00:00:00 +0000</pubDate>
      
      <guid>https://jreisinger.github.io/notes/posts/go-json/</guid>
      <description>Networked programs need to exchange information via messages. TCP and UDP provide a transport mechanism to do this. However, at transport level the messages are just sequences of bytes with no structure.
A program will typically build a complex data structure to hold the current program state. To transfer this data outside of the program&amp;rsquo;s own address space (e.g. to another application over the network) it needs to be serialized. This process is also called marshalling or encoding.</description>
    </item>
    
    <item>
      <title>TCP sockets with Go</title>
      <link>https://jreisinger.github.io/notes/posts/go-tcp-sockets/</link>
      <pubDate>Fri, 25 Jan 2019 00:00:00 +0000</pubDate>
      
      <guid>https://jreisinger.github.io/notes/posts/go-tcp-sockets/</guid>
      <description>Client This is an HTTP client implemented using socket-level programming:
// Usage: go run telnet.go package main import ( &amp;#34;bufio&amp;#34; &amp;#34;fmt&amp;#34; &amp;#34;net&amp;#34; ) func main() { // NOTE: ignoring errors by storing them into _  conn, _ := net.Dial(&amp;#34;tcp&amp;#34;, &amp;#34;golang.org:80&amp;#34;) // Connect over TCP  fmt.Fprintf(conn, &amp;#34;GET / HTTP/1.0\r\n\r\n&amp;#34;) // Send string over the connection  status, _ := bufio.NewReader(conn).ReadString(&amp;#39;\n&amp;#39;) fmt.Print(status) // Print the first response line } To add a timeout you can use the Dialer structure (I&amp;rsquo;ve also added error checking + reading from command line arguments):</description>
    </item>
    
    <item>
      <title>Go directory structure</title>
      <link>https://jreisinger.github.io/notes/posts/go-directory-structure/</link>
      <pubDate>Wed, 24 Oct 2018 00:00:00 +0000</pubDate>
      
      <guid>https://jreisinger.github.io/notes/posts/go-directory-structure/</guid>
      <description>NOTE: See How to Write Go Code for official tutorial.
Go has a strong opinion about directory structure.
## Set location of your workspace (It&amp;#39;s used by the `go` tool) $ export GOPATH=`pwd` $ echo $GOPATH /Users/reisinge/temp/go A single file program:
## Create a program $ tree . └── src └── hello # this directory name is the program name └── main.go # package main 2 directories, 1 file ## Install the program $ go install hello # compile and install all *.</description>
    </item>
    
    <item>
      <title>Sorting with Go</title>
      <link>https://jreisinger.github.io/notes/posts/sorting-with-go/</link>
      <pubDate>Wed, 24 Oct 2018 00:00:00 +0000</pubDate>
      
      <guid>https://jreisinger.github.io/notes/posts/sorting-with-go/</guid>
      <description>package main import ( &amp;#34;fmt&amp;#34; &amp;#34;sort&amp;#34; ) // A type with the three methods required for sorting. type StringSlice []string func (p StringSlice) Len() int { return len(p) } func (p StringSlice) Less(i, j int) bool { return p[i] &amp;lt; p[j] } func (p StringSlice) Swap(i, j int) { p[i], p[j] = p[j], p[i] } func main() { names := []string{&amp;#34;Xavier&amp;#34;, &amp;#34;John&amp;#34;, &amp;#34;Eve&amp;#34;, &amp;#34;Adam&amp;#34;} // sort.Strings(names) has the same effect 	sort.</description>
    </item>
    
    <item>
      <title>Reading from STDIN or from command line arguments</title>
      <link>https://jreisinger.github.io/notes/posts/read-stdin-or-args/</link>
      <pubDate>Wed, 08 Aug 2018 00:00:00 +0000</pubDate>
      
      <guid>https://jreisinger.github.io/notes/posts/read-stdin-or-args/</guid>
      <description>// Dup2 prints the count and text of lines that appear more than once // in the input. It reads from stdin or from a list of named files. package main import ( &amp;#34;bufio&amp;#34; &amp;#34;fmt&amp;#34; &amp;#34;os&amp;#34; ) func main() { counts := make(map[string]int) files := os.Args[1:] if len(files) == 0 { // STDIN  countLines(os.Stdin, counts) } else { // command line args  for _, arg := range files { f, err := os.</description>
    </item>
    
    <item>
      <title>Heap vs Stack</title>
      <link>https://jreisinger.github.io/notes/posts/heap-vs-stack/</link>
      <pubDate>Tue, 07 Aug 2018 08:43:41 +0200</pubDate>
      
      <guid>https://jreisinger.github.io/notes/posts/heap-vs-stack/</guid>
      <description>Both are memory regions.
Stack (temporary to a function)
 stores temporary variables created by functions LIFO data structure with push/pop operations all vars are popped off when function exits very fast limited in size  Heap (global)
 not as tightly managed by CPU in C you have to manage it yourself via malloc(), calloc() or realloc() if you fail you get a memory leak slower access because pointers are used limited only by physical memory  Go example:</description>
    </item>
    
  </channel>
</rss>